name: Release

on:
  push:
    tags:
      - "*"
  workflow_dispatch:
    inputs:
      tag_name:
        description: "Release tag (手动运行可自定义，留空则使用 manual-<short_sha>)"
        required: false
        default: ""
      release_name:
        description: "Release 名称（可选，默认与 tag 相同）"
        required: false
        default: ""
      prerelease:
        description: "是否标记为 Pre-release（手动运行默认 true）"
        required: false
        default: "false"
      create_release:
        description: "是否创建 GitHub Release（手动运行可设为 false，仅构建与产出 Actions Artifacts）"
        required: false
        default: "true"

permissions:
  contents: write

env:
  FLUTTER_VERSION: "3.27.3"

jobs:
  check-branch:
    name: Check if main branch
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Check branch
        run: |
          if [ "${{ github.ref_name }}" != "main" ]; then
            echo "❌ Release workflow can only be triggered from main branch"
            echo "Current branch: ${{ github.ref_name }}"
            exit 1
          fi
          echo "✅ Branch check passed: ${{ github.ref_name }}"

  android:
    name: Android (APK + AAB)
    runs-on: ubuntu-latest
    needs: [check-branch]
    if: always() && (needs.check-branch.result == 'success' || github.event_name == 'push')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Prepare release metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          IS_TAG="false"
          TAG_NAME=""
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            IS_TAG="true"
            TAG_NAME="${GITHUB_REF#refs/tags/}"
          fi
          if [[ -z "$TAG_NAME" ]]; then
            INPUT_TAG="${{ github.event.inputs.tag_name || '' }}"
            if [[ -n "$INPUT_TAG" ]]; then
              TAG_NAME="$INPUT_TAG"
            else
              SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-7)
              TAG_NAME="manual-${SHORT_SHA}"
            fi
          fi
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: "zulu"
          java-version: "17"

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Install Android build-tools and platforms
        run: |
          sdkmanager --install "platform-tools" "platforms;android-35" "build-tools;35.0.0"

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: "stable"
          cache: true

      - name: Flutter pub get
        run: flutter pub get

      - name: Setup Android signing from secrets (optional)
        env:
          ANDROID_KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
        run: |
          set -euo pipefail
          if [ -n "${ANDROID_KEYSTORE_BASE64:-}" ]; then
            echo "Writing Android keystore from secret..."
            mkdir -p android/app
            echo "$ANDROID_KEYSTORE_BASE64" | base64 -d > android/app/ci-release.keystore
            printf '%s\n' \
              'storeFile=ci-release.keystore' \
              "storePassword=${ANDROID_KEYSTORE_PASSWORD}" \
              "keyAlias=${ANDROID_KEY_ALIAS}" \
              "keyPassword=${ANDROID_KEY_PASSWORD}" \
              > android/key.properties
            echo "key.properties created."
          else
            echo "No Android signing secrets provided; will use fallback CI keystore in Gradle."
          fi

      - name: Update pubspec.yaml version
        run: |
          VERSION='${{ steps.meta.outputs.tag_name }}'
          echo "Updating pubspec.yaml version to: $VERSION"
          # 备份原始 pubspec.yaml
          cp pubspec.yaml pubspec.yaml.backup
          # 更新版本号，保持构建号递增
          # 从标签中提取版本号（去掉 v 前缀）
          CLEAN_VERSION=${VERSION#v}
          # 生成构建号（使用 GitHub run number）
          BUILD_NUMBER=${{ github.run_number }}
          # 更新 pubspec.yaml
          sed -i "s/^version: .*/version: ${CLEAN_VERSION}+${BUILD_NUMBER}/" pubspec.yaml
          echo "Updated version in pubspec.yaml:"
          grep "^version:" pubspec.yaml

      - name: Build APK (release)
        run: |
          export CI_VERSION='${{ steps.meta.outputs.tag_name }}'
          export GIT_COMMIT='${{ github.sha }}'
          export BUILD_TIME='${{ github.run_id }}'
          echo "Debug: CI_VERSION=$CI_VERSION"
          echo "Debug: TAG_NAME=${{ steps.meta.outputs.tag_name }}"
          flutter build apk --release --flavor prod \
            --dart-define=CI_VERSION="$CI_VERSION" \
            --dart-define=GIT_COMMIT="$GIT_COMMIT" \
            --dart-define=BUILD_TIME="$BUILD_TIME"

      - name: Build App Bundle (AAB)
        run: |
          export CI_VERSION='${{ steps.meta.outputs.tag_name }}'
          export GIT_COMMIT='${{ github.sha }}'
          export BUILD_TIME='${{ github.run_id }}'
          flutter build appbundle --release --flavor prod \
            --dart-define=CI_VERSION="$CI_VERSION" \
            --dart-define=GIT_COMMIT="$GIT_COMMIT" \
            --dart-define=BUILD_TIME="$BUILD_TIME"

      - name: List Android outputs (debug)
        run: |
          echo "== build/app/outputs =="
          ls -R build/app/outputs || true
          echo "== flutter-apk =="
          ls -la build/app/outputs/flutter-apk || true
          echo "== bundle =="
          ls -R build/app/outputs/bundle || true

      - name: Rename Android artifacts with version
        run: |
          VERSION="${{ steps.meta.outputs.tag_name }}"
          cd build/app/outputs
          # 重命名 APK
          if [ -f flutter-apk/app-prod-release.apk ]; then
            mv flutter-apk/app-prod-release.apk flutter-apk/beecount-${VERSION}.apk
            echo "Renamed APK to: beecount-${VERSION}.apk"
          fi
          # 重命名 AAB
          if [ -f bundle/prodRelease/app-prod-release.aab ]; then
            mv bundle/prodRelease/app-prod-release.aab bundle/prodRelease/beecount-${VERSION}.aab
            echo "Renamed AAB to: beecount-${VERSION}.aab"
          fi
          echo "=== Final Android artifacts ==="
          find . -name "*.apk" -o -name "*.aab"

      - name: Upload Android artifacts
        uses: actions/upload-artifact@v4
        with:
          name: android
          if-no-files-found: error
          path: |
            build/app/outputs/flutter-apk/beecount-*.apk
            build/app/outputs/bundle/prodRelease/beecount-*.aab

  ios:
    name: iOS (app.zip + unsigned .ipa)
    runs-on: macos-latest
    needs: [check-branch]
    if: always() && (needs.check-branch.result == 'success' || github.event_name == 'push')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Prepare release metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          IS_TAG="false"
          TAG_NAME=""
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            IS_TAG="true"
            TAG_NAME="${GITHUB_REF#refs/tags/}"
          fi
          if [[ -z "$TAG_NAME" ]]; then
            INPUT_TAG="${{ github.event.inputs.tag_name || '' }}"
            if [[ -n "$INPUT_TAG" ]]; then
              TAG_NAME="$INPUT_TAG"
            else
              SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-7)
              TAG_NAME="manual-${SHORT_SHA}"
            fi
          fi
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: "stable"
          cache: true

      - name: Flutter pub get
        run: flutter pub get

      - name: Update pubspec.yaml version (iOS)
        run: |
          VERSION='${{ steps.meta.outputs.tag_name }}'
          echo "Updating pubspec.yaml version to: $VERSION"
          # 备份原始 pubspec.yaml
          cp pubspec.yaml pubspec.yaml.backup
          # 更新版本号，保持构建号递增
          # 从标签中提取版本号（去掉 v 前缀）
          CLEAN_VERSION=${VERSION#v}
          # 生成构建号（使用 GitHub run number）
          BUILD_NUMBER=${{ github.run_number }}
          # 更新 pubspec.yaml
          sed -i "" "s/^version: .*/version: ${CLEAN_VERSION}+${BUILD_NUMBER}/" pubspec.yaml
          echo "Updated version in pubspec.yaml:"
          grep "^version:" pubspec.yaml

      - name: Setup iOS signing (optional)
        env:
          IOS_P12_BASE64: ${{ secrets.APPLE_CERTIFICATE_P12 }}
          IOS_P12_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          IOS_PROVISION_PROFILE_BASE64: ${{ secrets.APPLE_PROVISIONING_PROFILE }}
          IOS_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail
          if [ -n "${IOS_P12_BASE64:-}" ]; then
            echo "📱 Setting up iOS code signing from secrets..."

            # 创建临时keychain
            KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
            KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

            security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
            security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

            # 导入证书
            CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
            echo "$IOS_P12_BASE64" | base64 -d > $CERTIFICATE_PATH
            security import $CERTIFICATE_PATH -P "$IOS_P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
            security list-keychain -d user -s $KEYCHAIN_PATH

            # 安装provisioning profile
            PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
            echo "$IOS_PROVISION_PROFILE_BASE64" | base64 -d > $PP_PATH

            # 从 provisioning profile 中提取 UUID
            PP_UUID=$(security cms -D -i $PP_PATH | plutil -extract UUID raw -)
            echo "Provisioning Profile UUID: $PP_UUID"

            # 使用 UUID 作为文件名安装到正确位置
            mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
            cp $PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles/${PP_UUID}.mobileprovision
            echo "✅ Installed provisioning profile: ${PP_UUID}.mobileprovision"

            # 调试：显示 provisioning profile 详细信息
            echo "📋 Provisioning Profile details:"
            security cms -D -i $PP_PATH | plutil -p - | grep -A 5 -E "(Name|UUID|TeamIdentifier|AppIDName)"

            # 设置 codesign 权限
            security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

            # 调试：列出所有可用的签名身份
            echo "📋 Available signing identities in keychain:"
            security find-identity -v -p codesigning $KEYCHAIN_PATH

            echo ""
            echo "📋 All signing identities on system:"
            security find-identity -v -p codesigning

            # 动态生成 ExportOptions.plist（使用 printf 避免 heredoc YAML 冲突）
            printf '%s\n' \
              '<?xml version="1.0" encoding="UTF-8"?>' \
              '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' \
              '<plist version="1.0">' \
              '<dict>' \
              '    <key>method</key>' \
              '    <string>app-store</string>' \
              '    <key>teamID</key>' \
              "    <string>${IOS_TEAM_ID}</string>" \
              '    <key>uploadBitcode</key>' \
              '    <false/>' \
              '    <key>uploadSymbols</key>' \
              '    <true/>' \
              '    <key>signingStyle</key>' \
              '    <string>manual</string>' \
              '    <key>signingCertificate</key>' \
              '    <string>Apple Distribution</string>' \
              '    <key>provisioningProfiles</key>' \
              '    <dict>' \
              '        <key>com.tntlikely.beecount</key>' \
              '        <string>BeeCount_AppStore</string>' \
              '    </dict>' \
              '</dict>' \
              '</plist>' \
              > ios/ExportOptions.plist

            echo "✅ iOS signing configured"
            echo "IOS_SIGNING_ENABLED=true" >> $GITHUB_ENV
          else
            echo "⚠️  No iOS signing secrets provided; will build unsigned only"
            echo "IOS_SIGNING_ENABLED=false" >> $GITHUB_ENV
          fi

      - name: Build iOS (no codesign)
        run: |
          export CI_VERSION='${{ steps.meta.outputs.tag_name }}'
          export GIT_COMMIT='${{ github.sha }}'
          export BUILD_TIME='${{ github.run_id }}'
          flutter build ios --release --no-codesign \
            --dart-define=CI_VERSION="$CI_VERSION" \
            --dart-define=GIT_COMMIT="$GIT_COMMIT" \
            --dart-define=BUILD_TIME="$BUILD_TIME"

      - name: Configure Xcode project for signing
        if: env.IOS_SIGNING_ENABLED == 'true'
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          PROJECT_FILE="ios/Runner.xcodeproj/project.pbxproj"

          # 1. 配置手动签名
          sed -i '' 's/CODE_SIGN_STYLE = Automatic;/CODE_SIGN_STYLE = Manual;/g' "$PROJECT_FILE"

          # 2. 修改签名身份为发布证书
          sed -i '' 's/"CODE_SIGN_IDENTITY\[sdk=iphoneos\*\]" = "iPhone Developer";/"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "Apple Distribution";/g' "$PROJECT_FILE"

          # 3. 使用perl在每个buildSettings块后添加配置（更可靠）
          perl -i -pe "s/(buildSettings = \\{)/\$1\n\t\t\t\tDEVELOPMENT_TEAM = ${APPLE_TEAM_ID};\n\t\t\t\tPROVISIONING_PROFILE_SPECIFIER = \\\"BeeCount_AppStore\\\";/g" "$PROJECT_FILE"

          echo "✅ Configured manual signing for Xcode project"
          echo "Signing configuration:"
          grep -E "CODE_SIGN_STYLE|CODE_SIGN_IDENTITY|DEVELOPMENT_TEAM|PROVISIONING_PROFILE_SPECIFIER" "$PROJECT_FILE" | head -30

      - name: Build iOS (signed, release)
        if: env.IOS_SIGNING_ENABLED == 'true'
        run: |
          export CI_VERSION='${{ steps.meta.outputs.tag_name }}'
          export GIT_COMMIT='${{ github.sha }}'
          export BUILD_TIME='${{ github.run_id }}'

          # 使用 flutter build ipa 并通过 --export-options-plist 指定签名配置
          flutter build ipa --release \
            --export-options-plist=ios/ExportOptions.plist \
            --dart-define=CI_VERSION="$CI_VERSION" \
            --dart-define=GIT_COMMIT="$GIT_COMMIT" \
            --dart-define=BUILD_TIME="$BUILD_TIME"

      - name: Copy signed IPA to release directory
        if: env.IOS_SIGNING_ENABLED == 'true'
        run: |
          set -euo pipefail
          VERSION="${{ steps.meta.outputs.tag_name }}"

          # flutter build ipa 会在 build/ios/ipa 目录生成 IPA
          if [ -f build/ios/ipa/*.ipa ]; then
            cp build/ios/ipa/*.ipa beecount-${VERSION}-signed.ipa
            echo "✅ Copied signed IPA: beecount-${VERSION}-signed.ipa"
            ls -lh beecount-${VERSION}-signed.ipa
          else
            echo "❌ Signed IPA not found in build/ios/ipa/"
            ls -la build/ios/ipa/ || true
            exit 1
          fi

      - name: Cleanup iOS keychain
        if: always() && env.IOS_SIGNING_ENABLED == 'true'
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true

      - name: Build iOS (debug simulator, unsigned)
        run: |
          export CI_VERSION='${{ steps.meta.outputs.tag_name }}'
          export GIT_COMMIT='${{ github.sha }}'
          export BUILD_TIME='${{ github.run_id }}'
          flutter build ios --debug --simulator \
            --dart-define=CI_VERSION="$CI_VERSION" \
            --dart-define=GIT_COMMIT="$GIT_COMMIT" \
            --dart-define=BUILD_TIME="$BUILD_TIME"

      - name: Package iOS Runner.app (unsigned)
        run: |
          set -euo pipefail
          VERSION="${{ steps.meta.outputs.tag_name }}"
          APP_PATH="build/ios/iphoneos/Runner.app"
          if [ ! -d "$APP_PATH" ]; then
            echo "Runner.app not found at $APP_PATH" >&2
            ls -la build/ios/iphoneos || true
            exit 1
          fi
          # 生成包含版本号的文件名
          ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" beecount-${VERSION}-iphoneos.app.zip
          mkdir -p Payload
          cp -R "$APP_PATH" Payload/
          /usr/bin/zip -qry beecount-${VERSION}-unsigned.ipa Payload
          echo "Generated iOS artifacts:"
          ls -la beecount-${VERSION}-*

      - name: Package iOS Simulator Runner.app (debug, unsigned)
        run: |
          set -euo pipefail
          VERSION="${{ steps.meta.outputs.tag_name }}"
          SIM_APP_PATH="build/ios/iphonesimulator/Runner.app"
          if [ -d "$SIM_APP_PATH" ]; then
            ditto -c -k --sequesterRsrc --keepParent "$SIM_APP_PATH" beecount-${VERSION}-iphonesimulator.app.zip
            echo "Generated iOS Simulator artifact: beecount-${VERSION}-iphonesimulator.app.zip"
          else
            echo "Simulator Runner.app not found at $SIM_APP_PATH" >&2
            ls -la build/ios/iphonesimulator || true
          fi

      - name: Upload to TestFlight
        if: env.IOS_SIGNING_ENABLED == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          set -euo pipefail
          VERSION="${{ steps.meta.outputs.tag_name }}"
          IPA_FILE="beecount-${VERSION}-signed.ipa"

          if [ -z "${APPLE_ID:-}" ] || [ -z "${APPLE_APP_SPECIFIC_PASSWORD:-}" ]; then
            echo "⚠️  APPLE_ID or APPLE_APP_SPECIFIC_PASSWORD not set, skipping TestFlight upload"
            exit 0
          fi

          if [ ! -f "$IPA_FILE" ]; then
            echo "❌ Signed IPA not found: $IPA_FILE"
            exit 1
          fi

          echo "📤 Uploading $IPA_FILE to TestFlight..."
          xcrun altool --upload-app \
            --type ios \
            --file "$IPA_FILE" \
            --username "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --verbose

          echo "✅ Successfully uploaded to TestFlight!"

      - name: Upload iOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ios
          path: |
            beecount-*-iphoneos.app.zip
            beecount-*-unsigned.ipa
            beecount-*-signed.ipa
            beecount-*-iphonesimulator.app.zip

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs:
      - check-branch
      - android
      - ios
    if: always() && (needs.check-branch.result == 'success' || github.event_name == 'push') && needs.android.result == 'success' && needs.ios.result == 'success'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Ensure tags are fetched
        run: |
          git fetch --tags --force || true

      - name: Prepare release metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          IS_TAG="false"
          TAG_NAME=""
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            IS_TAG="true"
            TAG_NAME="${GITHUB_REF#refs/tags/}"
          fi
          if [[ -z "$TAG_NAME" ]]; then
            INPUT_TAG="${{ github.event.inputs.tag_name || '' }}"
            if [[ -n "$INPUT_TAG" ]]; then
              TAG_NAME="$INPUT_TAG"
            else
              SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-7)
              TAG_NAME="manual-${SHORT_SHA}"
            fi
          fi
          # 手动触发默认 prerelease=true；tag 触发默认 false
          INPUT_PRERELEASE="${{ github.event.inputs.prerelease || '' }}"
          if [[ "$IS_TAG" == "true" ]]; then
            PRERELEASE="false"
          else
            PRERELEASE=${INPUT_PRERELEASE:-true}
          fi
          # 是否创建 Release
          INPUT_CREATE="${{ github.event.inputs.create_release || '' }}"
          if [[ "$IS_TAG" == "true" ]]; then
            CREATE_RELEASE="true"
          else
            CREATE_RELEASE=${INPUT_CREATE:-false}
          fi
          RELEASE_NAME_INPUT="${{ github.event.inputs.release_name || '' }}"
          if [[ -n "$RELEASE_NAME_INPUT" ]]; then
            RELEASE_NAME="$RELEASE_NAME_INPUT"
          else
            RELEASE_NAME="$TAG_NAME"
          fi
          echo "is_tag=$IS_TAG" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "prerelease=$PRERELEASE" >> $GITHUB_OUTPUT
          echo "create_release=$CREATE_RELEASE" >> $GITHUB_OUTPUT
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
      - name: Download Android artifacts
        uses: actions/download-artifact@v4
        with:
          name: android
          path: ./dist/android

      - name: List downloaded artifacts (debug)
        run: |
          echo "== dist tree =="
          ls -R ./dist || true

      - name: Download iOS artifacts
        uses: actions/download-artifact@v4
        with:
          name: ios
          path: ./dist/ios

      - name: Generate release notes
        id: notes
        run: |
          TAG="${{ steps.meta.outputs.tag_name }}"
          # 获取上一个 tag（不含当前 tag）
          PREV_TAG=$(git tag --list --sort=-version:refname | grep -v "^${TAG}$" | head -n1)
          echo "Current tag: $TAG"
          echo "Previous tag: $PREV_TAG"
          # 生成 commit 列表（排除 merge commit）
          if [ -n "$PREV_TAG" ]; then
            echo "Generating commit log from $PREV_TAG to HEAD"
            COMMITS=$(git log --no-merges --pretty=format:"- %s ([%h](https://github.com/${GITHUB_REPOSITORY}/commit/%H))" "$PREV_TAG"..HEAD)
          else
            echo "No previous tag found, showing all commits"
            COMMITS=$(git log --no-merges --pretty=format:"- %s ([%h](https://github.com/${GITHUB_REPOSITORY}/commit/%H))")
          fi
          cat > RELEASE_NOTES.md <<EOF

          ## 变更记录
          $COMMITS

          EOF
          echo "notes_file=RELEASE_NOTES.md" >> $GITHUB_OUTPUT

      - name: Create Release
        if: ${{ steps.meta.outputs.create_release == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.meta.outputs.tag_name }}
          name: ${{ steps.meta.outputs.release_name }}
          prerelease: ${{ steps.meta.outputs.prerelease == 'true' }}
          body_path: ${{ steps.notes.outputs.notes_file }}
          files: |
            dist/android/**/*.apk
            dist/android/**/*.aab
            dist/ios/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Send Telegram notification
        if: ${{ steps.meta.outputs.create_release == 'true' }}
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          TAG="${{ steps.meta.outputs.tag_name }}"
          RELEASE_URL="https://github.com/${GITHUB_REPOSITORY}/releases/tag/${TAG}"
          IS_PRERELEASE="${{ steps.meta.outputs.prerelease }}"

          # 获取 commit 变更列表（与 release notes 相同）
          PREV_TAG=$(git tag --list --sort=-version:refname | grep -v "^${TAG}$" | head -n1)
          if [ -n "$PREV_TAG" ]; then
            COMMITS=$(git log --no-merges --pretty=format:"- %s" "$PREV_TAG"..HEAD)
          else
            COMMITS=$(git log --no-merges --pretty=format:"- %s")
          fi

          # 转义 Markdown 特殊字符，然后进行 URL 编码
          COMMITS_ESCAPED=$(echo "$COMMITS" | sed 's/\*/\\*/g; s/_/\\_/g; s/\[/\\[/g; s/\]/\\]/g; s/`/\\`/g')
          # URL 编码变更内容（换行符转为 %0A）
          COMMITS_ENCODED=$(echo "$COMMITS_ESCAPED" | sed 's/$/%0A/g' | tr -d '\n')

          # 构建消息
          if [ "$IS_PRERELEASE" == "true" ]; then
            MESSAGE="🐝 *BeeCount ${TAG}* 发布（预览版）%0A%0A"
          else
            MESSAGE="🐝 *BeeCount ${TAG}* 发布%0A%0A"
          fi

          MESSAGE="${MESSAGE}🔗 [查看完整说明](${RELEASE_URL})%0A%0A"
          MESSAGE="${MESSAGE}*变更内容*:%0A${COMMITS_ENCODED}"

          # 发送到 Telegram
          if [ -n "${TELEGRAM_BOT_TOKEN:-}" ] && [ -n "${TELEGRAM_CHAT_ID:-}" ]; then
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d "chat_id=${TELEGRAM_CHAT_ID}" \
              -d "text=${MESSAGE}" \
              -d "parse_mode=Markdown" \
              -d "disable_web_page_preview=true"
            echo "✅ Telegram notification sent successfully!"
          else
            echo "⚠️  Telegram credentials not configured, skipping notification"
          fi
